<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Blue Monkey 3D — Banana Throw</title>
<style>
  html,body{margin:0;height:100%;background:#000;overflow:hidden;font-family:system-ui,Arial}
  #hud{position:fixed;top:8px;left:0;right:0;text-align:center;color:#fff;font-weight:700;text-shadow:0 1px 2px #000}
  canvas{touch-action:none}
</style>
</head>
<body>
<div id="hud">Drag/Arrows to move • Catch bananas • 30s</div>
<canvas id="game"></canvas>
<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
<script>
(()=> {
  const cvs = document.getElementById('game');
  const R = new THREE.WebGLRenderer({canvas:cvs, antialias:true});
  R.setClearColor(0x101418,1);

  const scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x101418, 24, 80);

  const cam = new THREE.PerspectiveCamera(60, 1, 0.1, 200);
  cam.position.set(0, 8, 18); cam.lookAt(0,3,0);

  function resize(){
    const w=innerWidth,h=innerHeight;
    cam.aspect=w/h; cam.updateProjectionMatrix();
    R.setSize(w,h,false);
    R.setPixelRatio(Math.min(2, devicePixelRatio||1));
  }
  addEventListener('resize', resize); resize();

  // Lights
  const amb = new THREE.AmbientLight(0xffffff, .45);
  const dir = new THREE.DirectionalLight(0xffffff, .9); dir.position.set(1,1.4,.8);
  const fill= new THREE.DirectionalLight(0x88aaff, .25); fill.position.set(-1,.6,-.6);
  scene.add(amb,dir,fill);

  // Materials
  const M = {
    blue  : new THREE.MeshToonMaterial({color:0x2d63ff}),
    face  : new THREE.MeshToonMaterial({color:0xffe1a8}),
    brown : new THREE.MeshToonMaterial({color:0x6b3e17}),
    leaf  : new THREE.MeshToonMaterial({color:0x1b8b3a}),
    grass : new THREE.MeshToonMaterial({color:0x1b6e2c}),
    yellow: new THREE.MeshToonMaterial({color:0xffd24d}),
    black : new THREE.MeshToonMaterial({color:0x0d0d0d}),
  };

  // Ground
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(200,100), M.grass);
  ground.rotation.x = -Math.PI/2; scene.add(ground);

  // Trees
  const lanes = [-9,-6,-3,0,3,6,9];
  const trees = new THREE.Group(); scene.add(trees);
  function addTree(x,z){
    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(.35,.55,5,10), M.brown);
    trunk.position.set(x,2.5,z);
    const crown = new THREE.Mesh(new THREE.ConeGeometry(2.6,3.4,10), M.leaf);
    crown.position.set(x,5.5,z);
    trees.add(trunk,crown);
  }
  for(let z=-15; z>=-75; z-=6){ lanes.forEach(x=> addTree(x, z+(Math.random()-0.5))); }

  // Monkey (rounded PS2-ish)
  function makeMonkey(){
    const g = new THREE.Group();
    const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.9, 1.2, 6, 12), M.blue); body.position.y=1.2;
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.75, 16, 14), M.blue); head.position.y=2.5;
    const face = new THREE.Mesh(new THREE.SphereGeometry(0.52, 16, 14, 0, Math.PI*2, 0, Math.PI/1.6), M.face);
    face.scale.set(1,0.85,1); face.position.set(0,2.55,0.55);
    const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.08,10,10), M.black);
    const eyeR = eyeL.clone(); eyeL.position.set(-0.22,2.65,0.95); eyeR.position.set(0.22,2.65,0.95);
    const nose = new THREE.Mesh(new THREE.SphereGeometry(0.06,10,10), M.black); nose.position.set(0,2.45,0.98);
    const armL = new THREE.Mesh(new THREE.CapsuleGeometry(0.18,0.9,4,10), M.blue);
    const armR = armL.clone(); armL.position.set(-0.95,1.7,0); armR.position.set(0.95,1.7,0);
    const legL = new THREE.Mesh(new THREE.CapsuleGeometry(0.22,0.8,4,10), M.blue);
    const legR = legL.clone(); legL.position.set(-0.35,0.4,0); legR.position.set(0.35,0.4,0);
    const curve = new THREE.CatmullRomCurve3([ new THREE.Vector3(0.2,1.2,-0.3), new THREE.Vector3(0.9,1.1,0.0), new THREE.Vector3(1.1,1.4,0.2) ]);
    const tail = new THREE.Mesh(new THREE.TubeGeometry(curve, 12, 0.08, 6, false), M.blue);
    tail.position.set(0,0,0);
    g.add(body, head, face, eyeL, eyeR, nose, armL, armR, legL, legR, tail);
    g.userData = {armL, armR};
    return g;
  }

  // Player monkey (front)
  const player = makeMonkey();
  player.position.set(0,0,0);
  scene.add(player);

  // Thrower monkey (back, lobbing bananas toward camera)
  const thrower = makeMonkey();
  thrower.position.set(0,0,-18);
  scene.add(thrower);

  // Banana (curved)
  function makeBanana(){
    const g = new THREE.Group();
    const c = new THREE.CatmullRomCurve3([
      new THREE.Vector3(-0.6, 0, 0),
      new THREE.Vector3(-0.1, 0.05, 0.02),
      new THREE.Vector3( 0.5, 0, 0)
    ]);
    const tube = new THREE.Mesh(new THREE.TubeGeometry(c, 12, 0.12, 8, false), M.yellow);
    const tipL = new THREE.Mesh(new THREE.ConeGeometry(0.12, 0.18, 6), M.black); tipL.position.set(-0.6,0,0); tipL.rotation.z= Math.PI/2;
    const tipR = new THREE.Mesh(new THREE.ConeGeometry(0.12, 0.18, 6), M.black); tipR.position.set( 0.6,0,0); tipR.rotation.z=-Math.PI/2;
    g.add(tube, tipL, tipR);
    return g;
  }

  // Game state
  const bananas = [];
  let t=0, nextThrow=0, score=0, timeLeft=30, playing=false, over=false;

  function reset(){
    bananas.forEach(b=> scene.remove(b.m));
    bananas.length=0; score=0; timeLeft=30; t=0; nextThrow=0; playing=false; over=false;
    player.position.x = 0;
  }
  reset();

  // Throw animation + spawn
  function throwBanana(){
    // pick a lane near player to aim at (with spread)
    const targetX = player.position.x + (Math.random()*2-1); // bias toward player
    const startX  = THREE.MathUtils.clamp(targetX + (Math.random()*2-1.5), -9.5, 9.5);

    // arm wind-up
    const arms = thrower.userData;
    let wind = 0;
    const windInt = setInterval(()=>{
      wind += 0.12;
      arms.armR.rotation.x = -Math.min(0.9, wind);
      if (wind >= 0.9){ clearInterval(windInt); doThrow(); }
    }, 16);

    function doThrow(){
      const m = makeBanana();
      m.position.set(startX, 3.2, thrower.position.z+0.8);
      scene.add(m);

      // ballistic toward camera (z increasing), a bit of arc on y
      const timeScale = 0.03;
      const vz = 0.18 + Math.random()*0.05;     // forward speed
      const vx = (targetX - startX) * 0.015;    // steer sideways toward target
      let  vy = 0.22 + Math.random()*0.06;      // initial upward impulse
      const g  = -0.015;                        // gravity

      bananas.push({ m, vx, vy, vz, rot: (Math.random()*0.02+0.01) });

      // release arm
      const relInt = setInterval(()=>{
        arms.armR.rotation.x += 0.18;
        if (arms.armR.rotation.x >= 0){ arms.armR.rotation.x = 0; clearInterval(relInt); }
      }, 16);
    }
  }

  // Input
  function pointer(e){
    const cx = (e.touches? e.touches[0].clientX : e.clientX);
    const nx = (cx/innerWidth)*2-1;
    player.position.x = THREE.MathUtils.clamp(nx*9.5, -9.5, 9.5);
    if (!playing && !over) playing = true;
    e.preventDefault();
  }
  R.domElement.addEventListener('pointerdown', pointer);
  R.domElement.addEventListener('pointermove', e=> { if (playing) pointer(e); }, {passive:false});
  addEventListener('keydown', e=>{
    const step=1.2;
    if(!playing && !over && (e.code==='Space'||e.code==='Enter')) playing=true;
    else if(playing){
      if(e.code==='ArrowLeft')  player.position.x = Math.max(-9.5, player.position.x-step);
      if(e.code==='ArrowRight') player.position.x = Math.min( 9.5, player.position.x+step);
    } else if(over && (e.code==='Space'||e.code==='Enter')) reset();
  });

  // Collision with player
  function caught(b){
    const p = player.position, q = b.m.position;
    const dx=Math.abs(q.x-p.x), dy=Math.abs(q.y-1.2), dz=Math.abs(q.z-p.z);
    return dx<1.0 && dy<1.2 && dz<1.3;
  }

  // HUD
  const hud = document.getElementById('hud');
  function setHUD(){
    if (over) hud.textContent = `Time! Score: ${score} — tap to replay`;
    else if (!playing) hud.textContent = 'Drag/Arrows to move • Catch bananas • 30s';
    else hud.textContent = `Score: ${score} • Time: ${Math.max(0,timeLeft).toFixed(1)}`;
  }

  // Tick
  function tick(){
    requestAnimationFrame(tick);

    if (playing && !over){
      // throw cadence
      if (t >= nextThrow){
        throwBanana();
        nextThrow = t + Math.floor(28 + Math.random()*16); // faster = more bananas
      }

      // update bananas (ballistic)
      bananas.forEach(b=>{
        b.m.position.x += b.vx;
        b.m.position.y += b.vy;
        b.m.position.z += b.vz;
        b.vy += -0.015; // gravity
        b.m.rotation.y += b.rot;
      });

      // collect / miss
      for (let i=bananas.length-1;i>=0;i--){
        const b = bananas[i];
        if (caught(b)){ score++; scene.remove(b.m); bananas.splice(i,1); continue; }
        if (b.m.position.y < 0.4){ scene.remove(b.m); bananas.splice(i,1); } // ground = missed
      }

      // timer
      if (t % 60 === 0) timeLeft -= 1;
      if (timeLeft <= 0){ over=true; playing=false; }
      t++;
    }

    // tiny camera bob
    cam.position.y = 8 + Math.sin(t*0.025)*0.15;

    R.render(scene, cam);
    setHUD();
  }
  tick();

  // restart on tap
  R.domElement.addEventListener('pointerdown', ()=>{ if (over) reset(); });
})();
</script>
</body>
</html>
