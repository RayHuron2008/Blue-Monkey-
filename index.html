<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Blue Monkey — 3D Maze Escape</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#000;font-family:system-ui,Arial}
  #hud{position:fixed;top:8px;left:0;right:0;text-align:center;color:#fff;font-weight:700;text-shadow:0 1px 2px #000;pointer-events:none}
  canvas{touch-action:none}
</style>
</head>
<body>
<div id="hud">Drag left to turn • Drag right to move • Escape the maze!</div>
<canvas id="view"></canvas>
<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>

<script>
(() => {
  // === renderer / scene / camera ===
  const cvs = document.getElementById('view');
  const R = new THREE.WebGLRenderer({canvas:cvs, antialias:true});
  R.setClearColor(0x0e1216,1);
  const scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x0e1216, 40, 140);

  const cam = new THREE.PerspectiveCamera(65, 1, 0.1, 500);
  cam.position.set(0, 6, 10);

  function resize(){
    const w=innerWidth,h=innerHeight;
    cam.aspect=w/h; cam.updateProjectionMatrix();
    R.setSize(w,h,false);
    R.setPixelRatio(Math.min(2, devicePixelRatio||1));
  }
  addEventListener('resize', resize); resize();

  // === lights ===
  scene.add(new THREE.AmbientLight(0xffffff, .45));
  const sun = new THREE.DirectionalLight(0xffffff, .9);
  sun.position.set(1,2,1);
  scene.add(sun);

  // === materials ===
  const mWall  = new THREE.MeshToonMaterial({color:0x25435a});
  const mFloor = new THREE.MeshToonMaterial({color:0x114a2a});
  const mExit  = new THREE.MeshToonMaterial({color:0x4cff7a, emissive:0x1cff65, emissiveIntensity:.6});

  // === maze generation (recursive backtracker) ===
  const CELLS = 15;           // odd number (walls between cells)
  const CELL  = 4;            // world size of a cell
  const H = 3;                // wall height

  // grid: 0 wall, 1 passage
  const W = CELLS*2+1, H2 = CELLS*2+1;
  const grid = Array.from({length:H2}, () => Array(W).fill(0));

  function carve(x,y){
    grid[y][x]=1;
    const dirs = [[2,0],[ -2,0],[0,2],[0,-2]].sort(()=>Math.random()-0.5);
    for(const [dx,dy] of dirs){
      const nx=x+dx, ny=y+dy;
      if(ny>0&&ny<H2-1&&nx>0&&nx<W-1 && grid[ny][nx]===0){
        grid[y+dy/2][x+dx/2]=1;
        carve(nx,ny);
      }
    }
  }
  carve(1,1);

  // pick a far exit cell
  let exitCell = {x:W-2, y:H2-2};
  // build meshes + wall AABBs for collision
  const walls = [];
  const floor = new THREE.Mesh(new THREE.PlaneGeometry(W*CELL, H2*CELL), mFloor);
  floor.rotation.x = -Math.PI/2;
  floor.position.set((W*CELL)/-2, 0, (H2*CELL)/-2);
  scene.add(floor);

  const wallGeo = new THREE.BoxGeometry(CELL, H, CELL);
  for(let y=0;y<H2;y++){
    for(let x=0;x<W;x++){
      if(grid[y][x]===0){
        const mesh = new THREE.Mesh(wallGeo, mWall);
        mesh.position.set(x*CELL - (W*CELL)/2 + CELL/2, H/2, y*CELL - (H2*CELL)/2 + CELL/2);
        scene.add(mesh);
        walls.push(new THREE.Box3().setFromObject(mesh));
      }
    }
  }

  // exit marker
  const exitBox = new THREE.Mesh(new THREE.BoxGeometry(CELL*0.8, H*0.8, CELL*0.8), mExit);
  exitBox.position.set(exitCell.x*CELL - (W*CELL)/2 + CELL/2, H*0.4, exitCell.y*CELL - (H2*CELL)/2 + CELL/2);
  scene.add(exitBox);
  let exitBB = new THREE.Box3().setFromObject(exitBox);

  // === monkey (simple rounded) ===
  function makeMonkey(){
    const g = new THREE.Group();
    const blue = new THREE.MeshToonMaterial({color:0x2d63ff});
    const face = new THREE.MeshToonMaterial({color:0xffe1a8});
    const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.6,0.9,6,12), blue); body.position.y=0.9;
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.5,16,14), blue); head.position.y=1.7;
    const patch= new THREE.Mesh(new THREE.SphereGeometry(0.36,16,14,0,Math.PI*2,0,Math.PI/1.6), face);
    patch.scale.set(1,0.85,1); patch.position.set(0,1.72,0.35);
    const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.06,10,10), new THREE.MeshToonMaterial({color:0x0d0d0d}));
    const eyeR = eyeL.clone(); eyeL.position.set(-0.15,1.8,0.72); eyeR.position.set(0.15,1.8,0.72);
    g.add(body,head,patch,eyeL,eyeR);
    return g;
  }
  const player = makeMonkey();
  // start near 1,1 cell
  const startX = 1*CELL - (W*CELL)/2 + CELL/2;
  const startZ = 1*CELL - (H2*CELL)/2 + CELL/2;
  player.position.set(startX,0,startZ);
  scene.add(player);

  // camera follow (third-person)
  let yaw = 0;
  function updateCamera(){
    const behind = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)).multiplyScalar(-6);
    cam.position.copy(player.position).add(new THREE.Vector3(0,4.2,0)).add(behind);
    cam.lookAt(player.position.x, player.position.y+1.2, player.position.z);
  }
  updateCamera();

  // === movement + collisions ===
  const vel = new THREE.Vector3();
  const speed = 0.09;
  const playerBB = new THREE.Box3();

  function moveAndCollide(dx, dz){
    const next = player.position.clone().add(new THREE.Vector3(dx,0,dz));
    // build bbox around next position
    const half=0.35, h=1.8;
    playerBB.set(
      new THREE.Vector3(next.x-half, 0, next.z-half),
      new THREE.Vector3(next.x+half, h, next.z+half)
    );
    // if collides with any wall, cancel move axis-by-axis
    let blockedX=false, blockedZ=false;
    for(const w of walls){
      if (w.intersectsBox(playerBB)){
        // test X only
        const testX = player.position.clone().add(new THREE.Vector3(dx,0,0));
        const bbX = playerBB.clone().translate(new THREE.Vector3(-dz,0,0)); // temp; quick hack
        bbX.min.set(testX.x-half, 0, player.position.z-half);
        bbX.max.set(testX.x+half, 1.8, player.position.z+half);
        if (w.intersectsBox(bbX)) blockedX=true;

        // test Z only
        const testZ = player.position.clone().add(new THREE.Vector3(0,0,dz));
        const bbZ = playerBB.clone();
        bbZ.min.set(player.position.x-half, 0, testZ.z-half);
        bbZ.max.set(player.position.x+half, 1.8, testZ.z+half);
        if (w.intersectsBox(bbZ)) blockedZ=true;

        if (blockedX && blockedZ) return; // both blocked: no move
      }
    }
    if (!blockedX) player.position.x += dx;
    if (!blockedZ) player.position.z += dz;
  }

  // === controls (touch + keyboard) ===
  let moveY=0, moveX=0, draggingL=false, draggingR=false, lastL=0, lastR=0;
  function onPointerDown(e){
    const x = e.clientX || e.touches[0].clientX;
    if (x < innerWidth*0.5){ draggingL=true; lastL = e.clientX || e.touches[0].clientX; }
    else { draggingR=true; lastR = e.clientX || e.touches[0].clientX; }
  }
  function onPointerMove(e){
    const cx = e.clientX || (e.touches? e.touches[0].clientX : 0);
    const cy = e.clientY || (e.touches? e.touches[0].clientY : 0);
    if (draggingL){
      const dx = (cx - lastL);
      yaw -= dx * 0.005; // turn
      lastL = cx;
    }
    if (draggingR){
      // map vertical drag to forward/back; horizontal to strafe slightly
      const dx = (cx - lastR); lastR = cx;
      moveX = THREE.MathUtils.clamp(dx*0.0025, -1, 1);
      // use TouchEvent’s changedTouches for Y delta (approx by wheel)
      // we’ll read window.onwheel for desktop; for touch mimic by small constant push
    }
    e.preventDefault();
  }
  function onPointerUp(){ draggingL=false; draggingR=false; moveX=0; }
  cvs.addEventListener('pointerdown', onPointerDown, {passive:false});
  cvs.addEventListener('pointermove', onPointerMove, {passive:false});
  addEventListener('pointerup', onPointerUp);

  // keyboard
  const keys = {};
  addEventListener('keydown', e=>{ keys[e.code]=true; });
  addEventListener('keyup',   e=>{ keys[e.code]=false; });

  // === game loop ===
  const hud = document.getElementById('hud');
  let won=false;

  function loop(){
    requestAnimationFrame(loop);

    // compute intended movement in facing space
    const forward = (keys['KeyW']||keys['ArrowUp']) ? 1 : (keys['KeyS']||keys['ArrowDown']) ? -1 : 0;
    const strafe  = (keys['KeyA']||keys['ArrowLeft']) ? -1 : (keys['KeyD']||keys['ArrowRight']) ? 1 : 0;

    // add tiny auto-forward when dragging right half (mobile)
    const dragForward = draggingR ? 1 : 0;

    const dir = new THREE.Vector3(
      Math.sin(yaw), 0, Math.cos(yaw)
    );
    const right = new THREE.Vector3(dir.z, 0, -dir.x);

    const dx = (dir.x*(forward+dragForward) + right.x*(strafe+moveX)) * speed;
    const dz = (dir.z*(forward+dragForward) + right.z*(strafe+moveX)) * speed;

    moveAndCollide(dx, dz);
    player.rotation.y = yaw;

    // follow cam
    updateCamera();

    // win check
    const playerBox = new THREE.Box3().setFromCenterAndSize(
      new THREE.Vector3(player.position.x, 1, player.position.z),
      new THREE.Vector3(0.8,2,0.8)
    );
    if (!won && playerBox.intersectsBox(exitBB)){
      won = true;
      hud.textContent = 'ESCAPED! Tap to generate a new maze';
      // click to regenerate
      addEventListener('pointerdown', ()=>location.reload(), {once:true});
    }

    R.render(scene, cam);
  }
  loop();
})();
</script>
</body>
</html>
